"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodePath = exports.fetchNodeKeys = exports.request = exports.CustomPath = void 0;
const _principal_1 = require("../../principal/index.js");
const errors_ts_1 = require("../errors.js");
const certificate_ts_1 = require("../certificate.js");
const cbor = __importStar(require("../cbor.js"));
const leb_ts_1 = require("../utils/leb.js");
const utils_1 = require("@noble/hashes/utils");
const readState_ts_1 = require("../utils/readState.js");
// Re-export shared types for backwards compatibility
var readState_ts_2 = require("../utils/readState.js");
Object.defineProperty(exports, "CustomPath", { enumerable: true, get: function () { return readState_ts_2.CustomPath; } });
/**
 * Requests information from a canister's `read_state` endpoint.
 * Can be used to request information about the canister's controllers, time, module hash, candid interface, and more.
 *
 * > [!WARNING]
 * > Requesting the `subnet` path from the canister status might be deprecated in the future.
 * > Use {@link https://js.icp.build/core/latest/libs/agent/api/namespaces/subnetstatus/functions/request | SubnetStatus.request} to fetch subnet information instead.
 * @param {CanisterStatusOptions} options The configuration for the canister status request.
 * @see {@link CanisterStatusOptions} for detailed options.
 * @returns {Promise<StatusMap>} A map populated with data from the requested paths. Each path is a key in the map, and the value is the data obtained from the certificate for that path.
 * @example
 * const status = await canisterStatus({
 *   paths: ['controllers', 'candid'],
 *   ...options
 * });
 *
 * const controllers = status.get('controllers');
 */
const request = async (options) => {
    const { agent, paths, disableCertificateTimeVerification = false } = options;
    const canisterId = _principal_1.Principal.from(options.canisterId);
    const uniquePaths = [...new Set(paths)];
    const status = new Map();
    const promises = uniquePaths.map((path, index) => {
        const encodedPath = (0, exports.encodePath)(path, canisterId);
        return (async () => {
            try {
                if (agent.rootKey === null) {
                    throw errors_ts_1.ExternalError.fromCode(new errors_ts_1.MissingRootKeyErrorCode());
                }
                const rootKey = agent.rootKey;
                const response = await agent.readState(canisterId, {
                    paths: [encodedPath],
                });
                const certificate = await certificate_ts_1.Certificate.create({
                    certificate: response.certificate,
                    rootKey,
                    principal: { canisterId },
                    disableTimeVerification: disableCertificateTimeVerification,
                    agent,
                });
                const lookup = (cert, path) => {
                    if (path === 'subnet') {
                        const data = (0, exports.fetchNodeKeys)(response.certificate, canisterId, rootKey);
                        return {
                            path,
                            data,
                        };
                    }
                    else {
                        return {
                            path,
                            data: (0, certificate_ts_1.lookupResultToBuffer)(cert.lookup_path(encodedPath)),
                        };
                    }
                };
                // must pass in the rootKey if we have no delegation
                const { path, data } = lookup(certificate, uniquePaths[index]);
                if (!data) {
                    // Typically, the cert lookup will throw
                    if (typeof path === 'string') {
                        status.set(path, null);
                    }
                    else {
                        status.set(path.key, null);
                    }
                }
                else {
                    switch (path) {
                        case 'time': {
                            status.set(path, (0, leb_ts_1.decodeTime)(data));
                            break;
                        }
                        case 'controllers': {
                            status.set(path, (0, readState_ts_1.decodeControllers)(data));
                            break;
                        }
                        case 'module_hash': {
                            status.set(path, (0, utils_1.bytesToHex)(data));
                            break;
                        }
                        case 'subnet': {
                            status.set(path, data);
                            break;
                        }
                        case 'candid': {
                            status.set(path, new TextDecoder().decode(data));
                            break;
                        }
                        default: {
                            // Check for CustomPath signature
                            if ((0, readState_ts_1.isCustomPath)(path)) {
                                status.set(path.key, (0, readState_ts_1.decodeValue)(data, path.decodeStrategy));
                            }
                        }
                    }
                }
            }
            catch (error) {
                // Throw on certificate errors
                if (error instanceof errors_ts_1.AgentError &&
                    (error.hasCode(errors_ts_1.CertificateVerificationErrorCode) ||
                        error.hasCode(errors_ts_1.CertificateTimeErrorCode))) {
                    throw error;
                }
                if ((0, readState_ts_1.isCustomPath)(path)) {
                    status.set(path.key, null);
                }
                else {
                    status.set(path, null);
                }
            }
        })();
    });
    // Fetch all values separately, as each option can fail
    await Promise.all(promises);
    return status;
};
exports.request = request;
/**
 * Lookup node keys from a certificate for a given canister.
 * The certificate is assumed to be already verified, including whether the canister is in range of the subnet.
 * @param certificate the certificate to lookup node keys from
 * @param canisterId the canister ID to lookup node keys for
 * @param root_key the root key to use to lookup node keys
 * @returns a map of node IDs to public keys
 */
const fetchNodeKeys = (certificate, canisterId, root_key) => {
    if (!canisterId._isPrincipal) {
        throw errors_ts_1.InputError.fromCode(new errors_ts_1.UnexpectedErrorCode('Invalid canisterId'));
    }
    const cert = cbor.decode(certificate);
    const { delegation } = cert;
    let subnetId;
    if (delegation && delegation.subnet_id) {
        subnetId = _principal_1.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));
    }
    else if (!delegation && typeof root_key !== 'undefined') {
        // On local replica, with System type subnet, there is no delegation
        subnetId = _principal_1.Principal.selfAuthenticating(new Uint8Array(root_key));
    }
    else {
        // otherwise use default NNS subnet id
        subnetId = readState_ts_1.IC_ROOT_SUBNET_ID;
    }
    const nodeKeys = (0, readState_ts_1.lookupNodeKeysFromCertificate)(cert, subnetId);
    return {
        subnetId: subnetId.toText(),
        nodeKeys,
    };
};
exports.fetchNodeKeys = fetchNodeKeys;
const encodePath = (path, canisterId) => {
    const canisterUint8Array = canisterId.toUint8Array();
    switch (path) {
        case 'time':
            return [(0, utils_1.utf8ToBytes)('time')];
        case 'controllers':
            return [(0, utils_1.utf8ToBytes)('canister'), canisterUint8Array, (0, utils_1.utf8ToBytes)('controllers')];
        case 'module_hash':
            return [(0, utils_1.utf8ToBytes)('canister'), canisterUint8Array, (0, utils_1.utf8ToBytes)('module_hash')];
        case 'subnet':
            return [(0, utils_1.utf8ToBytes)('subnet')];
        case 'candid':
            return [
                (0, utils_1.utf8ToBytes)('canister'),
                canisterUint8Array,
                (0, utils_1.utf8ToBytes)('metadata'),
                (0, utils_1.utf8ToBytes)('candid:service'),
            ];
        default: {
            // Check for CustomPath signature
            if ((0, readState_ts_1.isCustomPath)(path)) {
                // For simplified metadata queries
                if (typeof path['path'] === 'string' || path['path'] instanceof Uint8Array) {
                    return (0, readState_ts_1.encodeMetadataPath)(path.path, canisterUint8Array);
                }
                else {
                    // For non-metadata, return the provided custom path
                    return path['path'];
                }
            }
        }
    }
    throw errors_ts_1.UnknownError.fromCode(new errors_ts_1.UnexpectedErrorCode(`Error while encoding your path for canister status. Please ensure that your path ${path} was formatted correctly.`));
};
exports.encodePath = encodePath;
//# sourceMappingURL=index.js.map