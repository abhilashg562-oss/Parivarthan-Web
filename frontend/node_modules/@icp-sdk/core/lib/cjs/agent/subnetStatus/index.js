"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.IC_ROOT_SUBNET_ID = exports.CustomPath = void 0;
exports.request = request;
exports.lookupSubnetInfo = lookupSubnetInfo;
exports.encodePath = encodePath;
const _principal_1 = require("../../principal/index.js");
const errors_ts_1 = require("../errors.js");
const certificate_ts_1 = require("../certificate.js");
const cbor = __importStar(require("../cbor.js"));
const leb_ts_1 = require("../utils/leb.js");
const utils_1 = require("@noble/hashes/utils");
const readState_ts_1 = require("../utils/readState.js");
// Re-export shared types and functions
var readState_ts_2 = require("../utils/readState.js");
Object.defineProperty(exports, "CustomPath", { enumerable: true, get: function () { return readState_ts_2.CustomPath; } });
Object.defineProperty(exports, "IC_ROOT_SUBNET_ID", { enumerable: true, get: function () { return readState_ts_2.IC_ROOT_SUBNET_ID; } });
/**
 * Requests information from a subnet's `read_state` endpoint.
 * Can be used to request information about the subnet's time, canister ranges, public key, node keys, and metrics.
 * @param {SubnetStatusOptions} options The configuration for the subnet status request.
 * @see {@link SubnetStatusOptions} for detailed options.
 * @returns {Promise<StatusMap>} A map populated with data from the requested paths. Each path is a key in the map, and the value is the data obtained from the certificate for that path.
 * @example
 * const status = await subnetStatus.request({
 *   subnetId: IC_ROOT_SUBNET_ID,
 *   paths: ['time', 'nodeKeys'],
 *   agent,
 * });
 *
 * const time = status.get('time');
 * const nodeKeys = status.get('nodeKeys');
 */
async function request(options) {
    const { agent, paths, disableCertificateTimeVerification = false } = options;
    const subnetId = _principal_1.Principal.from(options.subnetId);
    const uniquePaths = [...new Set(paths)];
    const status = new Map();
    const promises = uniquePaths.map((path, index) => {
        const encodedPath = encodePath(path, subnetId);
        return (async () => {
            try {
                if (agent.rootKey === null) {
                    throw errors_ts_1.ExternalError.fromCode(new errors_ts_1.MissingRootKeyErrorCode());
                }
                const rootKey = agent.rootKey;
                const response = await agent.readSubnetState(subnetId, {
                    paths: [encodedPath],
                });
                const certificate = await certificate_ts_1.Certificate.create({
                    certificate: response.certificate,
                    rootKey,
                    principal: { subnetId },
                    disableTimeVerification: disableCertificateTimeVerification,
                    agent,
                });
                const lookup = (cert, lookupPath) => {
                    if (lookupPath === 'nodeKeys') {
                        // For node keys, we need to parse the certificate directly
                        const data = (0, readState_ts_1.lookupNodeKeysFromCertificate)(cert.cert, subnetId);
                        return {
                            path: lookupPath,
                            data,
                        };
                    }
                    else {
                        return {
                            path: lookupPath,
                            data: (0, certificate_ts_1.lookupResultToBuffer)(cert.lookup_path(encodedPath)),
                        };
                    }
                };
                const { path, data } = lookup(certificate, uniquePaths[index]);
                if (!data) {
                    if (typeof path === 'string') {
                        status.set(path, null);
                    }
                    else {
                        status.set(path.key, null);
                    }
                }
                else {
                    switch (path) {
                        case 'time': {
                            status.set(path, (0, leb_ts_1.decodeTime)(data));
                            break;
                        }
                        case 'canisterRanges': {
                            status.set(path, (0, certificate_ts_1.decodeCanisterRanges)(data));
                            break;
                        }
                        case 'publicKey': {
                            status.set(path, data);
                            break;
                        }
                        case 'nodeKeys': {
                            status.set(path, data);
                            break;
                        }
                        default: {
                            // Check for CustomPath signature
                            if ((0, readState_ts_1.isCustomPath)(path)) {
                                status.set(path.key, (0, readState_ts_1.decodeValue)(data, path.decodeStrategy));
                            }
                        }
                    }
                }
            }
            catch (error) {
                // Throw on certificate errors
                if (error instanceof errors_ts_1.AgentError &&
                    (error.hasCode(errors_ts_1.CertificateVerificationErrorCode) ||
                        error.hasCode(errors_ts_1.CertificateTimeErrorCode))) {
                    throw error;
                }
                if ((0, readState_ts_1.isCustomPath)(path)) {
                    status.set(path.key, null);
                }
                else {
                    status.set(path, null);
                }
            }
        })();
    });
    // Fetch all values separately, as each option can fail
    await Promise.all(promises);
    return status;
}
/**
 * Fetch subnet info including node keys from a certificate
 * @param certificate the certificate bytes
 * @param subnetId the subnet ID
 * @returns SubnetStatus with subnet ID and node keys
 */
function lookupSubnetInfo(certificate, subnetId) {
    const cert = cbor.decode(certificate);
    const nodeKeys = (0, readState_ts_1.lookupNodeKeysFromCertificate)(cert, subnetId);
    const publicKey = lookupSubnetPublicKey(cert, subnetId);
    return {
        subnetId: subnetId.toText(),
        nodeKeys,
        publicKey,
    };
}
function lookupSubnetPublicKey(certificate, subnetId) {
    const subnetLookupResult = (0, certificate_ts_1.lookup_path)(['subnet', subnetId.toUint8Array(), 'public_key'], certificate.tree);
    if (subnetLookupResult.status !== certificate_ts_1.LookupPathStatus.Found) {
        throw errors_ts_1.ProtocolError.fromCode(new errors_ts_1.LookupErrorCode('Public key not found', subnetLookupResult.status));
    }
    return subnetLookupResult.value;
}
/**
 * Encode a path for subnet state queries
 * @param path the path to encode
 * @param subnetId the subnet ID
 * @returns the encoded path as an array of Uint8Arrays
 */
function encodePath(path, subnetId) {
    const subnetUint8Array = subnetId.toUint8Array();
    switch (path) {
        case 'time':
            return [(0, utils_1.utf8ToBytes)('time')];
        case 'canisterRanges':
            return [(0, utils_1.utf8ToBytes)('canister_ranges'), subnetUint8Array];
        case 'publicKey':
            return [(0, utils_1.utf8ToBytes)('subnet'), subnetUint8Array, (0, utils_1.utf8ToBytes)('public_key')];
        case 'nodeKeys':
            return [(0, utils_1.utf8ToBytes)('subnet'), subnetUint8Array, (0, utils_1.utf8ToBytes)('node')];
        default: {
            // Check for CustomPath signature
            if ((0, readState_ts_1.isCustomPath)(path)) {
                if (typeof path['path'] === 'string' || path['path'] instanceof Uint8Array) {
                    // For string paths, treat as a subnet path segment
                    const encoded = typeof path['path'] === 'string' ? (0, utils_1.utf8ToBytes)(path['path']) : path['path'];
                    return [(0, utils_1.utf8ToBytes)('subnet'), subnetUint8Array, encoded];
                }
                else {
                    // For non-simple paths, return the provided custom path
                    return path['path'];
                }
            }
        }
    }
    throw errors_ts_1.UnknownError.fromCode(new errors_ts_1.UnexpectedErrorCode(`Error while encoding your path for subnet status. Please ensure that your path ${path} was formatted correctly.`));
}
//# sourceMappingURL=index.js.map