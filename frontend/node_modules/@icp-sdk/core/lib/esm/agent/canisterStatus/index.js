import { Principal } from '../../principal/index.js';
import { CertificateVerificationErrorCode, MissingRootKeyErrorCode, ExternalError, AgentError, UnknownError, UnexpectedErrorCode, InputError, CertificateTimeErrorCode, } from "../errors.js";
import { Certificate, lookupResultToBuffer } from "../certificate.js";
import * as cbor from "../cbor.js";
import { decodeTime } from "../utils/leb.js";
import { utf8ToBytes, bytesToHex } from '@noble/hashes/utils';
import { decodeValue, decodeControllers, encodeMetadataPath, isCustomPath, lookupNodeKeysFromCertificate, IC_ROOT_SUBNET_ID, } from "../utils/readState.js";
// Re-export shared types for backwards compatibility
export { CustomPath } from "../utils/readState.js";
/**
 * Requests information from a canister's `read_state` endpoint.
 * Can be used to request information about the canister's controllers, time, module hash, candid interface, and more.
 *
 * > [!WARNING]
 * > Requesting the `subnet` path from the canister status might be deprecated in the future.
 * > Use {@link https://js.icp.build/core/latest/libs/agent/api/namespaces/subnetstatus/functions/request | SubnetStatus.request} to fetch subnet information instead.
 * @param {CanisterStatusOptions} options The configuration for the canister status request.
 * @see {@link CanisterStatusOptions} for detailed options.
 * @returns {Promise<StatusMap>} A map populated with data from the requested paths. Each path is a key in the map, and the value is the data obtained from the certificate for that path.
 * @example
 * const status = await canisterStatus({
 *   paths: ['controllers', 'candid'],
 *   ...options
 * });
 *
 * const controllers = status.get('controllers');
 */
export const request = async (options) => {
    const { agent, paths, disableCertificateTimeVerification = false } = options;
    const canisterId = Principal.from(options.canisterId);
    const uniquePaths = [...new Set(paths)];
    const status = new Map();
    const promises = uniquePaths.map((path, index) => {
        const encodedPath = encodePath(path, canisterId);
        return (async () => {
            try {
                if (agent.rootKey === null) {
                    throw ExternalError.fromCode(new MissingRootKeyErrorCode());
                }
                const rootKey = agent.rootKey;
                const response = await agent.readState(canisterId, {
                    paths: [encodedPath],
                });
                const certificate = await Certificate.create({
                    certificate: response.certificate,
                    rootKey,
                    principal: { canisterId },
                    disableTimeVerification: disableCertificateTimeVerification,
                    agent,
                });
                const lookup = (cert, path) => {
                    if (path === 'subnet') {
                        const data = fetchNodeKeys(response.certificate, canisterId, rootKey);
                        return {
                            path,
                            data,
                        };
                    }
                    else {
                        return {
                            path,
                            data: lookupResultToBuffer(cert.lookup_path(encodedPath)),
                        };
                    }
                };
                // must pass in the rootKey if we have no delegation
                const { path, data } = lookup(certificate, uniquePaths[index]);
                if (!data) {
                    // Typically, the cert lookup will throw
                    if (typeof path === 'string') {
                        status.set(path, null);
                    }
                    else {
                        status.set(path.key, null);
                    }
                }
                else {
                    switch (path) {
                        case 'time': {
                            status.set(path, decodeTime(data));
                            break;
                        }
                        case 'controllers': {
                            status.set(path, decodeControllers(data));
                            break;
                        }
                        case 'module_hash': {
                            status.set(path, bytesToHex(data));
                            break;
                        }
                        case 'subnet': {
                            status.set(path, data);
                            break;
                        }
                        case 'candid': {
                            status.set(path, new TextDecoder().decode(data));
                            break;
                        }
                        default: {
                            // Check for CustomPath signature
                            if (isCustomPath(path)) {
                                status.set(path.key, decodeValue(data, path.decodeStrategy));
                            }
                        }
                    }
                }
            }
            catch (error) {
                // Throw on certificate errors
                if (error instanceof AgentError &&
                    (error.hasCode(CertificateVerificationErrorCode) ||
                        error.hasCode(CertificateTimeErrorCode))) {
                    throw error;
                }
                if (isCustomPath(path)) {
                    status.set(path.key, null);
                }
                else {
                    status.set(path, null);
                }
            }
        })();
    });
    // Fetch all values separately, as each option can fail
    await Promise.all(promises);
    return status;
};
/**
 * Lookup node keys from a certificate for a given canister.
 * The certificate is assumed to be already verified, including whether the canister is in range of the subnet.
 * @param certificate the certificate to lookup node keys from
 * @param canisterId the canister ID to lookup node keys for
 * @param root_key the root key to use to lookup node keys
 * @returns a map of node IDs to public keys
 */
export const fetchNodeKeys = (certificate, canisterId, root_key) => {
    if (!canisterId._isPrincipal) {
        throw InputError.fromCode(new UnexpectedErrorCode('Invalid canisterId'));
    }
    const cert = cbor.decode(certificate);
    const { delegation } = cert;
    let subnetId;
    if (delegation && delegation.subnet_id) {
        subnetId = Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));
    }
    else if (!delegation && typeof root_key !== 'undefined') {
        // On local replica, with System type subnet, there is no delegation
        subnetId = Principal.selfAuthenticating(new Uint8Array(root_key));
    }
    else {
        // otherwise use default NNS subnet id
        subnetId = IC_ROOT_SUBNET_ID;
    }
    const nodeKeys = lookupNodeKeysFromCertificate(cert, subnetId);
    return {
        subnetId: subnetId.toText(),
        nodeKeys,
    };
};
export const encodePath = (path, canisterId) => {
    const canisterUint8Array = canisterId.toUint8Array();
    switch (path) {
        case 'time':
            return [utf8ToBytes('time')];
        case 'controllers':
            return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('controllers')];
        case 'module_hash':
            return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('module_hash')];
        case 'subnet':
            return [utf8ToBytes('subnet')];
        case 'candid':
            return [
                utf8ToBytes('canister'),
                canisterUint8Array,
                utf8ToBytes('metadata'),
                utf8ToBytes('candid:service'),
            ];
        default: {
            // Check for CustomPath signature
            if (isCustomPath(path)) {
                // For simplified metadata queries
                if (typeof path['path'] === 'string' || path['path'] instanceof Uint8Array) {
                    return encodeMetadataPath(path.path, canisterUint8Array);
                }
                else {
                    // For non-metadata, return the provided custom path
                    return path['path'];
                }
            }
        }
    }
    throw UnknownError.fromCode(new UnexpectedErrorCode(`Error while encoding your path for canister status. Please ensure that your path ${path} was formatted correctly.`));
};
//# sourceMappingURL=index.js.map